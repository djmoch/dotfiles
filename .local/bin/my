#!/bin/sh
#
# ~/.local/bin/my
#

# Command and handlers for them are added as-needed. Some commands only
# have one handler, but exist to avoid re-writes across my dotfiles
# later on.

[ $# -eq 0 ] && exit 1

log="$HOME/.local/var/log/my"
command=$1
shift

__mylog()
{
    echo "$1 (`date +'%m/%d/%Y %H:%M:%S'`): $2" >> $log
}

__getlocker()
{
    for locker in light-locker cinnamon-screensaver gnome-screensaver xscreensaver
    do
        if type $locker-command > /dev/null 2>&1 && ps -U $LOGNAME -o command= | grep ^[^_[:space:]]*$locker > /dev/null 2>&1
        then
            echo $locker
            exit 0
        fi
    done

    __mylog "__getlocker" "No screen locker running"
    exit 1
}

case $command in
    mailto)
        for m in mutt mail
        do
            if type $m > /dev/null 2>&1
            then
                mailer=$m
                break
            fi
        done
        if [ -n "$2" ]
        then
            $mailer -s "$2" $1
        else
            $mailer $1
        fi
        ;;
    search)
        query=`echo $1 | tr ' ' '+'`
        exec my open -T https://duckduckgo.com/?q=$query
        ;;
    term)
        SHLVL=0; export SHLVL
        if type urxvtd > /dev/null 2>&1
        then
            urxvtc "$@"
            if [ "$?" -eq 2 ]
            then
                urxvtd -q -o -f
                urxvtc "$@"
            fi
            exit 0
        elif type urxvt > /dev/null 2>&1
        then
            exec urxvt "$@"
        elif type xterm > /dev/null 2>&1
        then
            exec xterm "$@"
        elif type x-terminal-emulator > /dev/null 2>&1
        then
            exec x-terminal-emulator "$@"
        fi

        [ "$1" = "-e" ] && shift && set -- "-x" $@
        if type xfce4-terminal > /dev/null 2>&1
        then
            exec xfce4-terminal "$@"
        elif type gnome-terminal > /dev/null 2>&1
        then
            exec gnome-terminal "$@"
        fi

        __mylog "my term" "No terminal emulator found"
        exit 1
        ;;
    lock)
        sleep 1

        locker=`__getlocker`

        if [ -z "$locker" ]
        then
            __mylog "my lock" "no locker running"
            exit 1
        fi
        [ "$locker" = "light-locker" ] || $locker-command -l
        exec xset dpms force off
        ;;
    wallpaper)
        xsetroot -solid "#444444"
        [ -x "$HOME/.fehbg" ] && "$HOME/.fehbg" >> $log 2>&1
        ;;
    standby)
        if type systemctl > /dev/null 2>&1
        then
            locker=`__getlocker`
            if [ -z "$locker" ]
            then
                __mylog "my standby" "no locker running"
                exit 1
            fi
            if [ ! "$locker" = "light-locker" ]
            then
                sleep 1
                $locker-command -l
                xset dpms force off
            fi
            exec systemctl hybrid-sleep
        else
            __mylog "my standby" "No handler found"
        fi
        ;;
    shutdown)
        if type systemctl > /dev/null 2>&1
        then
            exec systemctl poweroff
        elif type poweroff > /dev/null 2>&1
        then
            exec my term -e sudo poweroff
        else
            __mylog "my shutdown" "No handler found"
        fi
        ;;
    perms)
        exec my-perms "$@"
        ;;
    init)
        exec my-init "$@"
        ;;
    open)
        exec my-open "$@"
        ;;
    sound)
        if type pactl > /dev/null 2>&1 && pactl stat > /dev/null 2>&1
        then
            [ -z "$1" ] && exit 1
            if [ $1 = "status" ]
            then
                sink_status=`pactl list sinks | grep ^[[:space:]]*Volume | awk '{print $5}'`
                source_status=`pactl list sources | grep ^[[:space:]]*Volume | awk '{print $5}'`
                echo -n "Sinks: "
                for sink in $sink_status
                do
                    echo -n "$sink "
                done
                echo ""
                echo -n "Sources: "
                for source in $source_status
                do
                    echo -n "$source "
                done
                echo ""
                exit 0
            else
                exec pactl "$@"
            fi
        else
            __mylog "my sound" "No handler found"
        fi
        ;;
    kbopts)
        setxkbmap -option -option ctrl:nocaps -option terminate:ctrl_alt_bksp
        ;;
    screen)
        xrandr_options=`xrandr -q | grep ' disconnected' | awk '{print $1}'`
        for option in $xrandr_options
        do
            xrandr --output $option --off
        done

        xrandr_options=`xrandr -q | grep ' connected' | awk '{print $1}'`
        numoptions=`echo $xrandr_options | wc -w`
        if [ $numoptions -eq 1 ]
        then
            xrandr --output $xrandr_options --auto --primary
        else
            # Prefer external monitors
            # If more than one display is connected, then enable the
            # first non-primary display, and turn off all the others.
            primary=`xrandr -q | grep primary | awk '{print $1}'`

            for option in $xrandr_options
            do
                [ $option = $primary ] && primary_found=1 && continue
                [ -n "$primary_found" ] && selection=$option && break
            done

            xrandr --output $selection --auto --primary

            for option in $xrandr_options
            do
                [ $option != $selection ] && xrandr --output $option --off
            done
        fi
        exec my wallpaper
        ;;
    brightness)
        if type xbacklight > /dev/null 2>&1
        then
            if [ "$1" = "monitor" ]
            then
                # Future-proofing ... gmux is specific, imagine other
                # systems will be different
                for opt in gmux
                do
                    selection=`xbacklight -list | grep $opt`
                    num=`echo $selection | wc -w`
                    [ $num -gt 0 ] && break
                done
            else
                selection=`xbacklight -list | grep $1`
                num=`echo $selection | wc -w`
            fi
            [ $num -gt 1 ] && __mylog "my brightness" "More than one $1" && exit 1
            [ $num -lt 1 ] && __mylog "my brightness" "No $1 to adjust" && exit 1
            shift
            exec xbacklight -ctrl $selection "$@"
        else
            __mylog "my brightness" "No handler found"
        fi
        ;;
    battery)
        uname=`uname -s`

        case $1 in
            remaining)
                case $uname in 
                    *Linux*)
                        if [ `acpi | wc -l` -eq 2 ]
                        then
                            acpi | awk 'getline' | awk '{print $4}' | sed 's~%~~' | sed 's~,~~'
                        else
                            acpi | awk '{print $4}' | sed 's~%~~' | sed 's~,~~'
                        fi
                        ;;
                    *Darwin*)
                        battery_info=`ioreg -rc AppleSmartBattery`
                        echo $battery_info | grep -o '"CurrentCapacity" = [0-9]\+' | awk '{print $3}'
                        ;;
                    *CYGWIN*)
                        wmic path Win32_Battery Get EstimatedChargeRemaining /format:list 2>/dev/null | grep '[^[:blank:]]' | cut -d= -f2
                        ;;
                    *)
                        echo "no battery status"
                        exit 1
                esac
                exit 0
                ;;
            total)
                case $uname in 
                    *Linux*|*CYGWIN*)
                        echo 100
                        ;;
                    *Darwin*)
                        battery_info=`ioreg -rc AppleSmartBattery`
                        echo $battery_info | grep -o '"MaxCapacity" = [0-9]\+' | awk '{print $3}'
                        ;;
                    *)
                        echo "no battery status"
                        exit 1
                esac
                exit 0
                ;;
            percent)
                echo "$((`my battery remaining` * 100 / `my battery total`))"
                exit 0
                ;;
        esac
        ;;
    status)
        echo -n "Batt: `my battery percent`% | "
        cat $HOME/.local/var/forecastio/current_forecast.txt | tr -d '\n'
        echo -n " | "
        date +'%l:%M %p'
        exit 0
        ;;
    i3status)
            while :
            do
                echo "`my status`" || exit 1
                sleep 15
            done
        ;;
    copy)
        uname=`uname -s`

        case $uname in
            *Darwin*)
                reattach-to-user-namespace pbcopy
                ;;
            *CYGWIN*)
                cat > /dev/clipboard
                ;;
            *Linux*)
                xclip -selection clipboard
                ;;
            *)
                return
        esac
        ;;
    paste)
        uname=`uname -s`

        case $uname in
            *Darwin*)
                reattach-to-user-namespace pbpaste
                ;;
            *CYGWIN*)
                cat /dev/clipboard
                ;;
            *Linux*)
                xclip -o
                ;;
            *)
                return
        esac
        ;;
    netrc)
        exec my-netrc "$@"
        ;;
    dotfiles)
        predicate="$1" && shift
        case $predicate in
            check)
                cd "$HOME"
                find . -maxdepth 1 -name ._.djmoch -mtime +8 -exec echo "Dotfiles more than one week old" \;
                ;;
            update)
                if type sha256sum > /dev/null 2>&1
                then
                    sha_exec=sha256sum
                    fieldnum=1 
                else
                    sha_exec=sha256
                    fieldnum=4
                fi
                if [ -d "$HOME/.dotfiles" ]
                then
                    cd "$HOME/.dotfiles"
                    status=`git fetch --dry-run`
                    [ ! "$status" = "" ] && git pull --no-commit > /dev/null 2>&1
                elif [ -d "$HOME/.dotfiles_tgz" ]
                then
                    curl -s https://git.danielmoch.com/dotfiles/snapshot/dotfiles-master.tar.gz > /tmp/dotfiles.tgz.$$
                    oldsum=`$sha_exec "$HOME/.dotfiles_tgz/dotfiles.tar.gz" | cut -d ' ' -f $fieldnum`
                    newsum=`$sha_exec "/tmp/dotfiles.tgz.$$" | cut -d ' ' -f $fieldnum`
                    if [ ! "$oldsum" = "$newsum" ]
                    then
                        mv /tmp/dotfiles.tgz.$$ "$HOME/.dotfiles_tgz/dotfiles.tar.gz"
                        cd "$HOME"
                        tar xzf .dotfiles_tgz/dotfiles.tar.gz --strip=1
                    else
                        rm /tmp/dotfiles.tgz.$$
                    fi
                fi
                my init -f > /dev/null 2>&1
                touch "$HOME/._.djmoch"
                ;;
        esac
        ;;
    cron)
        [ "$1" = systemd ] && mycron_systemd=1
        case ":$PATH:" in
            *:"$HOME/.local/bin":*) ;;
            *) PATH="$HOME/.local/bin:$PATH" ;;
        esac
        cronpath="$HOME/.local/lib/cron.d"
        logpath="$HOME/.local/var/log"
        for job in $cronpath/*
        do
            if [ -x $job ]
            then
                if [ -n "$mycron_systemd" ]
                then
                    $job
                else
                    $job > $logpath/`basename $job` 2>&1
                fi
            fi
        done
        ;;
    login_async)
        starttime=`date '+%s'`
        runningtime=0
        while [ $runningtime -le 120 ]
        do
            if ping -c 1 danielmoch.com > /dev/null 2>&1
            then
                connected=1
                break
            fi
            sleep 1
            runningtime=$((`date '+%s'` - $starttime))
        done
        if [ -n "$connected" ]
        then
            cd "$HOME"
            find . -maxdepth 1 -name ._.djmoch -mtime +8 -exec my dotfiles update \;
        fi
        ;;
    login)
        my login_async &
        ;;
    *) echo "my: command $command not found" >&2
esac
