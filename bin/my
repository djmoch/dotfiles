#!/bin/sh
#
# ~/bin/my
#

# Command and handlers for them are added as-needed. Some commands only
# have one handler, but exist to avoid re-writes across my dotfiles
# later on.

[ $# -eq 0 ] && exit 1

log="$HOME/var/log/my"
command=$1
shift

__mylog()
{
	echo "$1 (`date +'%m/%d/%Y %H:%M:%S'`): $2" >> $log
}

__getlocker()
{
	if type slock > /dev/null 2>&1
	then
	echo slock
	exit 0
	fi
	for locker in slock light-locker cinnamon-screensaver gnome-screensaver xscreensaver
	do
		if my processes | grep $locker > /dev/null 2>&1
		then
			echo $locker
			exit 0
		fi
	done

	__mylog "__getlocker" "No screen locker running"
	exit 1
}

case $command in
	mailto)
		for m in mutt mail
		do
			if type $m > /dev/null 2>&1
			then
				mailer=$m
				break
			fi
		done
		if [ -n "$2" ]
		then
			$mailer -s "$2" $1
		else
			$mailer $1
		fi
		;;
	search)
		query=`echo $1 | tr ' ' '+'`
		exec my open -T https://duckduckgo.com/?q=$query
		;;
	term)
		SHLVL=0; export SHLVL
	if type st > /dev/null 2>&1
	then
		exec st "$@"
		elif type urxvtd > /dev/null 2>&1
		then
			urxvtc "$@"
			if [ "$?" -eq 2 ]
			then
				urxvtd -q -o -f
				urxvtc "$@"
			fi
			exit 0
		elif type urxvt > /dev/null 2>&1
		then
			exec urxvt "$@"
		elif type xterm > /dev/null 2>&1
		then
			exec xterm "$@"
		elif type x-terminal-emulator > /dev/null 2>&1
		then
			exec x-terminal-emulator "$@"
		fi

		[ "$1" = "-e" ] && shift && set -- "-x" $@
		if type xfce4-terminal > /dev/null 2>&1
		then
			exec xfce4-terminal "$@"
		elif type gnome-terminal > /dev/null 2>&1
		then
			exec gnome-terminal "$@"
		fi

		__mylog "my term" "No terminal emulator found"
		exit 1
		;;
	lock)
		sleep 1

		locker=`__getlocker`

		if [ -z "$locker" ]
		then
			__mylog "my lock" "no locker running"
			exit 1
		fi
		[ "$locker" = "light-locker" -o "$locker"="slock" ] || $locker-command -l
		exec xset dpms force off
		;;
	wallpaper)
		xsetroot -solid "#444444"
		[ -x "$HOME/.fehbg" ] && "$HOME/.fehbg" >> $log 2>&1
		;;
	standby)
		if type systemctl > /dev/null 2>&1
		then
			locker=`__getlocker`
			if [ -z "$locker" ]
			then
				__mylog "my standby" "no locker running"
				exit 1
			fi
			if [ ! "$locker" = "light-locker" ]
			then
				sleep 1
				$locker-command -l
				xset dpms force off
			fi
			exec systemctl hybrid-sleep
		else
			__mylog "my standby" "No handler found"
		fi
		;;
	shutdown)
		if type systemctl > /dev/null 2>&1
		then
			exec systemctl poweroff
		elif type poweroff > /dev/null 2>&1
		then
			exec my term -e sudo poweroff
		else
			__mylog "my shutdown" "No handler found"
		fi
		;;
	perms)
		exec my-perms "$@"
		;;
	init)
		exec my-init "$@"
		;;
	open)
		exec my-open "$@"
		;;
	sound)
		if type pactl > /dev/null 2>&1 && pactl stat > /dev/null 2>&1
		then
			[ -z "$1" ] && exit 1
			if [ $1 = "status" ]
			then
				sink_status=`pactl list sinks | grep ^[[:space:]]*Volume | awk '{print $5}'`
				source_status=`pactl list sources | grep ^[[:space:]]*Volume | awk '{print $5}'`
				echo -n "Sinks: "
				for sink in $sink_status
				do
					echo -n "$sink "
				done
				echo ""
				echo -n "Sources: "
				for source in $source_status
				do
					echo -n "$source "
				done
				echo ""
				exit 0
			else
				exec pactl "$@"
			fi
		else
			__mylog "my sound" "No handler found"
		fi
		;;
	kbopts)
		setxkbmap -option -option ctrl:nocaps
		;;
	screen)
		xrandr_options=`xrandr -q | grep ' disconnected' | awk '{print $1}'`
		for option in $xrandr_options
		do
			xrandr --output $option --off
		done

		xrandr_options=`xrandr -q | grep ' connected' | awk '{print $1}'`
		numoptions=`echo $xrandr_options | wc -w`
		if [ $numoptions -eq 1 ]
		then
			xrandr --output $xrandr_options --auto --primary
		else
			# Prefer external monitors
			# If more than one display is connected, then enable the
			# first non-primary display, and turn off all the others.
			primary=`xrandr -q | grep primary | awk '{print $1}'`

			for option in $xrandr_options
			do
				[ $option = $primary ] && primary_found=1 && continue
				[ -n "$primary_found" ] && selection=$option && break
			done

			xrandr --output $selection --auto --primary

			for option in $xrandr_options
			do
				[ $option != $selection ] && xrandr --output $option --off
			done
		fi
		exec my wallpaper
		;;
	brightness)
		if type xbacklight > /dev/null 2>&1
		then
			if xbacklight -list > /dev/null 2>&1
			then
				if [ "$1" = "monitor" ]
				then
					# Future-proofing ... gmux is specific, imagine other
					# systems will be different
					for opt in gmux intel_backlight
					do
						selection=`xbacklight -list | grep $opt`
						num=`echo $selection | wc -w`
						[ $num -gt 0 ] && break
					done
				else
					selection=`xbacklight -list | grep $1`
					num=`echo $selection | wc -w`
				fi
				[ $num -gt 1 ] && __mylog "my brightness" "More than one $1" && exit 1
				[ $num -lt 1 ] && __mylog "my brightness" "No $1 to adjust" && exit 1
				shift
				exec xbacklight -ctrl $selection "$@"
			else
				if [ "$1" = "monitor" ]
				then
					shift
					exec xbacklight "$@"
				else
					__mylog "my brightness" "handler incapable of adjusting key brightness"
				fi
			fi
		else
			__mylog "my brightness" "No handler found"
		fi
		;;
	battery)
		uname=`uname -s`

		case $1 in
			remaining)
				case $uname in
					*Linux*)
						if [ `acpi | wc -l` -eq 2 ]
						then
							acpi | awk 'getline' | awk '{print $4}' | sed 's~%~~' | sed 's~,~~'
						else
							acpi | awk '{print $4}' | sed 's~%~~' | sed 's~,~~'
						fi
						;;
					*Darwin*)
						battery_info=`ioreg -rc AppleSmartBattery`
						echo $battery_info | grep -o '"CurrentCapacity" = [0-9]\+' | awk '{print $3}'
						;;
					*CYGWIN*)
						wmic path Win32_Battery Get EstimatedChargeRemaining /format:list 2>/dev/null | grep '[^[:blank:]]' | cut -d= -f2
						;;
					*)
						echo "no battery status"
						exit 1
				esac
				exit 0
				;;
			total)
				case $uname in
					*Linux*|*CYGWIN*)
						echo 100
						;;
					*Darwin*)
						battery_info=`ioreg -rc AppleSmartBattery`
						echo $battery_info | grep -o '"MaxCapacity" = [0-9]\+' | awk '{print $3}'
						;;
					*)
						echo "no battery status"
						exit 1
				esac
				exit 0
				;;
			percent)
				echo "$((`my battery remaining` * 100 / `my battery total`))"
				exit 0
				;;
		esac
		;;
	status)
		echo -n "Batt: `my battery percent`% | "
		cat $HOME/var/forecastio/current_forecast.txt | tr -d '\n'
		echo -n " | "
		date +'%l:%M %p'
		exit 0
		;;
	i3status)
			while :
			do
				echo "`my status`" || exit 1
				sleep 15
			done
		;;
	copy)
		uname=`uname -s`

		case $uname in
			*Darwin*)
				reattach-to-user-namespace pbcopy
				;;
			*CYGWIN*)
				cat > /dev/clipboard
				;;
			*Linux*)
				xclip -selection clipboard
				;;
			*)
				return
		esac
		;;
	paste)
		uname=`uname -s`

		case $uname in
			*Darwin*)
				reattach-to-user-namespace pbpaste
				;;
			*CYGWIN*)
				cat /dev/clipboard
				;;
			*Linux*)
				xclip -o
				;;
			*)
				return
		esac
		;;
	netrc)
		exec my-netrc "$@"
		;;
	dotfiles)
		predicate="$1" && shift
		case $predicate in
			check)
				cd "$HOME"
			aweekago=$(($(date +%s) - 604800))
			lastupdate=$(stat --format=%Y ._.djmoch)
			[ $lastupdate -lt $aweekago ] && "Dotfiles more than one week old"
				;;
			update)
				if [ -d "$HOME/.dotfiles_tgz" ]
				then

					if type sha256sum > /dev/null 2>&1
					then
						sha_exec=sha256sum
						fieldnum=1
					else
						sha_exec=sha256
						fieldnum=4
					fi

					curl -s https://git.danielmoch.com/dotfiles/snapshot/dotfiles-master.tar.gz > /tmp/dotfiles.tgz.$$
					oldsum=`$sha_exec "$HOME/.dotfiles_tgz/dotfiles.tar.gz" | cut -d ' ' -f $fieldnum`
					newsum=`$sha_exec "/tmp/dotfiles.tgz.$$" | cut -d ' ' -f $fieldnum`
					if [ ! "$oldsum" = "$newsum" ]
					then
						mv /tmp/dotfiles.tgz.$$ "$HOME/.dotfiles_tgz/dotfiles.tar.gz"
						cd "$HOME"
						tar xzf .dotfiles_tgz/dotfiles.tar.gz
						for file in $(ls -A dotfiles-master)
			do
				cp -r dotfiles-master/$file .
			done
						rm -rf dotfiles-master
					else
						rm /tmp/dotfiles.tgz.$$
					fi
				fi
				my init -f > /dev/null 2>&1
				touch "$HOME/._.djmoch"
				;;
		esac
		;;
	cron)
		[ "$1" = systemd ] && mycron_systemd=1
		case ":$PATH:" in
			*:"$HOME/bin":*) ;;
			*) PATH="$HOME/bin:$PATH" ;;
		esac
		cronpath="$HOME/lib/cron.d"
		logpath="$HOME/var/log"
		for job in $cronpath/*
		do
			if [ -x $job ]
			then
				if [ -n "$mycron_systemd" ]
				then
					$job
				else
					$job > $logpath/`basename $job` 2>&1
				fi
			fi
		done
		;;
	login_async)
		starttime=`date '+%s'`
		runningtime=0
		while [ $runningtime -le 120 ]
		do
			if ping -c 1 danielmoch.com > /dev/null 2>&1
			then
				connected=1
				break
			fi
			sleep 1
			runningtime=$((`date '+%s'` - $starttime))
		done
		if [ -n "$connected" ]
		then
			cd "$HOME"
		aweekago=$(($(date +%s) - 604800))
		lastupdate=$(stat --format=%Y ._.djmoch)
		[ $lastupdate -lt $aweekago ] && my dotfiles update
		fi
		;;
	login)
		my login_async &
		;;
	processes)
		if [ -L /bin/ps ]
		then
			# busybox
			ps -o user,comm= | grep $LOGNAME | awk '{print $2;}'
		else
			ps -U $LOGNAME -o comm=
		fi
		;;
	*) echo "my: command $command not found" >&2
esac
